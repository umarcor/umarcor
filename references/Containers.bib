@online{docker,
  author = {Hykes, Solomon and {Docker, Inc.} and {contributors}},
  year = {2013},
  title = {Docker},
  url = {https://www.docker.com}
}

@online{docker-official-images,
  author = {{Docker contributors}},
  year = {2015},
  title = {docker-library/official-images: Architectures other than amd64?},
  url = {https://github.com/docker-library/official-images#architectures-other-than-amd64}
}

@article{merkel14,
 author = {Merkel, Dirk},
 title = {Docker: Lightweight Linux Containers for Consistent Development and Deployment},
 journal = {Linux J.},
 issue_date = {March 2014},
 volume = {2014},
 number = {239},
 month = mar,
 year = {2014},
 issn = {1075-3583},
 articleno = {2},
 url = {http://dl.acm.org/citation.cfm?id=2600239.2600241},
 publisher = {Belltown Media},
}

@online{gh:opencontainers,
  author = {{Open Container Initiative contributors}},
  title = {{GitHub: opencontainers}},
  url = {https://github.com/opencontainers}
}

@online{w:opencontainers,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Open Container Initiative}},
  url = {https://en.wikipedia.org/wiki/Open_Container_Initiative}
}

@online{opencontainers,
  author = {{Linux Foundation}},
  year = {2005},
  title = {Open Container Initiative (OCI)},
  url = {https://opencontainers.org/}
}

@online{gh:qemu,
  author = {{QEMU contributors}},
  title = {{GitHub: qemu}},
  url = {https://github.com/qemu}
}

@online{w:qemu,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: QEMU}},
  url = {https://en.wikipedia.org/wiki/QEMU}
}

@online{qemu,
  author = {Bellard, Fabrice and {contributors}},
  year = {2005},
  title = {QEMU, the FAST! processor emulator},
  url = {https://www.qemu.org/}
}

@inproceedings{bellard05,
 author = {Bellard, Fabrice},
 title = {{QEMU, a Fast and Portable Dynamic Translator}},
 booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},
 series = {ATEC '05},
 year = {2005},
 location = {Anaheim, CA},
 pages = {41--41},
 numpages = {1},
 url = {https://www.qemu.org/},
 acmid = {1247401},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@online{gh:docker,
  author = {{Docker contributors}},
  title = {{GitHub: docker}},
  url = {https://github.com/docker}
}

@online{w:docker,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Docker (software)}},
  url = {https://en.wikipedia.org/wiki/Docker_%28software%29}
}

@online{w:continuousintegration,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Continuous integration}},
  url = {https://en.wikipedia.org/wiki/Continuous_integration}
}

@online{w:github,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: GitHub}},
  url = {https://en.wikipedia.org/wiki/GitHub#GitHub.com}
}

@online{gha,
  author = {{GitHub}},
  year = {2019},
  title = {GitHub Actions},
  url = {https://github.com/features/actions}
}

@online{w:travis,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Travis CI}},
  url = {https://en.wikipedia.org/wiki/Travis_CI}
}

@online{travis-ci,
  author = {{Travis CI, GmbH}},
  year = {2011},
  title = {Travis CI},
  url = {https://travis-ci.org/}
}

@online{w:sbc,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Single-board computer}},
  url = {https://en.wikipedia.org/wiki/Single-board_computer}
}

@online{w:soc,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: System on a chip}},
  url = {https://en.wikipedia.org/wiki/System_on_a_chip}
}

@online{w:rpi,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Raspberry Pi}},
  url = {https://en.wikipedia.org/wiki/Raspberry_Pi}
}

@online{w:binary-translation,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Binary translation}},
  url = {https://en.wikipedia.org/wiki/Binary_translation}
}

@online{w:static-build,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Static build}},
  url = {https://en.wikipedia.org/wiki/Static_build}
}

@online{w:binfmt_misc,
  author = {{Wikipedia contributors}},
  title = {{Wikipedia: Binfmt_misc}},
  url = {https://en.wikipedia.org/wiki/Binfmt_misc}
}

@online{rottenkolber15,
  author = {Rottenkolber, Max},
  year = {2015},
  title = {Building VM Images from Docker Containers},
  url = {https://mr.gy/blog/build-vm-image-with-docker.html}
}

@online{golfayi,
  author = {{golfayi}},
  year = {2018},
  title = {Convert qcow2 image to docker image},
  url = {https://github.com/golfayi/Convert-qcow2-image-to-docker-image}
}

@online{katacontainers,
  author = {{OpenStack Foundation}},
  year = {2017},
  title = {Kata Containers, open source container runtime, building lightweight virtual machines that seamlessly plug into the containers ecosystem},
  url = {https://katacontainers.io}
}

@online{taylor16,
  author = {Taylor, Louis},
  year = {2016},
  title = {Raspbian on Travis CI},
  url = {http://blog.kragniz.eu/raspbian-on-travis-ci/}
}

@Online{rouault16,
  author = {Rouault, Even},
  title  = {Running FreeBSD in Travis-CI},
  url    = {http://erouault.blogspot.com/2016/09/running-freebsd-in-travis-ci.html},
  year   = {2016},
}

@online{voipio17,
  author = {Voipio, Riku},
  year = {2017},
  title = {Linux-User Support in QEMU},
  url = {https://www.youtube.com/watch?v=4MaGnMGPIq0}
}

@online{dbhi-containers,
  author = {Martinez-Corral, Unai},
  year = {2018},
  title = {dbhi/containers, containerized open and free development tools for Dynamic Binary Hardware Injection (DBHI)},
  url = {https://github.com/dbhi/containers}
}

@online{kernelnewbies,
  author = {{KernelNewbies contributors}},
  year = {2016},
  title = {KernelNewbies: Linux_4.8},
  url = {https://kernelnewbies.org/Linux_4.8?highlight=%28binfmt%29}
}

@online{corbet16,
  author = {Corbet, Jonathan},
  year = {2016},
  title = {Architecture emulation containers with binfmt_misc},
  url = {https://lwn.net/Articles/679308/}
}

@online{bottomley16,
  author = {Bottomley, James},
  year = {2016},
  title = {binfmt_misc: add persistent opened binary handler for containers},
  url = {https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=948b701a607f123df92ed29084413e5dd8cda2ed}
}

@online{aruga19,
  author = {Aruga, Jun},
  year = {2019},
  title = {Let's add Fedora multiarch containers to your CI},
  url = {https://github.com/junaruga/fedora-workshop-multiarch/blob/master/slides/Lets-add-Fedora-multiarch-to-CI.pdf}
}

@online{pradipta17,
  author = {Kumar, Pradipta},
  year = {2017},
  title = {Travis with Docker and QEMU for multi-architecture CI workflow},
  url = {https://developer.ibm.com/linuxonpower/2017/07/28/travis-multi-architecture-ci-workflow/}
}

@online{angelatos15,
  author = {Angelatos, Petros},
  year = {2015},
  title = {Building ARM containers on any x86 machine, even DockerHub},
  url = {https://www.balena.io/blog/building-arm-containers-on-any-x86-machine-even-dockerhub/}
}

@Article{azuma22,
  author={Azuma, Hideaki and Matsumoto, Shinsuke and Kamei, Yasutaka and Kusumoto, Shinji},
  title={An empirical study on self-admitted technical debt in Dockerfiles},
  journal={Empirical Software Engineering},
  year={2022},
  month={Jan},
  day={31},
  volume={27},
  number={2},
  pages={49},
  abstract={In software development, ad hoc solutions that are intentionally implemented by developers are called self-admitted technical debt (SATD). Because the existence of SATD spreads poor implementations, it is necessary to remove it as soon as possible. Meanwhile, container virtualization has been attracting attention in recent years as a technology to support infrastructure such as servers. Currently, Docker is the de facto standard for container virtualization. In Docker, a file describing how to build a container (Dockerfile) is a set of procedural instructions; thus, it can be considered as a kind of source code. Moreover, because Docker is a relatively new technology, there are few developers who have accumulated good or bad practices for building Docker container. Hence, it is likely that Dockerfiles contain many SATDs, as is the case with general programming language source code analyzed in previous SATD studies. The goal of this paper is to categorize SATDs in Dockerfiles and to share knowledge with developers and researchers. To achieve this goal, we conducted a manual classification for SATDs in Dockerfile. We found that about 3.0{\%} of the comments in Dockerfile are SATD. In addition, we have classified SATDs into five classes and eleven subclasses. Among them, there are some SATDs specific to Docker, such as SATDs for version fixing and for integrity check. The three most common classes of SATD were related to lowering maintainability, testing, and defects.},
  issn={1573-7616},
  doi={10.1007/s10664-021-10081-7},
  url={https://doi.org/10.1007/s10664-021-10081-7}
}

@misc{deochake23,
  title={Comparative Study of Virtual Machines and Containers for DevOps Developers},
  author={Saurabh Deochake and Sumit Maheshwari and Ridip De and Anish Grover},
  year={2023},
  eprint={1808.08192},
  archivePrefix={arXiv},
  primaryClass={cs.OS}
}

@article{santos18,
  title = {How does docker affect energy consumption? Evaluating workloads in and out of Docker containers},
  journal = {Journal of Systems and Software},
  volume = {146},
  pages = {14-25},
  year = {2018},
  issn = {0164-1212},
  doi = {https://doi.org/10.1016/j.jss.2018.07.077},
  url = {https://www.sciencedirect.com/science/article/pii/S0164121218301456},
  author = {Eddie Antonio Santos and Carson McLean and Christopher Solinas and Abram Hindle},
  keywords = {Virtualization, Docker, Containerization, Energy consumption, Cloud computing, Microservice},
  abstract = {Context: Virtual machines provide isolation of services at the cost of hypervisors and more resource usage. This spurred the growth of systems like Docker that enable single hosts to isolate several applications, similar to VMs, within a low-overhead abstraction called containers. Motivation: Although containers tout low overhead performance, how much do they increase energy use? Methodology: This work statistically compares the energy consumption of three application workloads in Docker and on bare-metal Linux. Results: In all cases, there was a statistically significant (t-test and Wilcoxon p < .05) increase in energy consumption when running tests in Docker, mostly due to the performance of I/O system calls. Developers worried about I/O overhead could consider baremetal deployments over Docker container deployments.}
}

@ARTICLE{hale17,
  author={Hale, Jack S. and Li, Lizao and Richardson, Christopher N. and Wells, Garth N.},
  journal={Computing in Science & Engineering},
  title={Containers for Portable, Productive, and Performant Scientific Computing},
  year={2017},
  volume={19},
  number={6},
  pages={40-50},
  doi={10.1109/MCSE.2017.2421459}
}

@article{belmann15,
  author = {Belmann, Peter and Dröge, Johannes and Bremges, Andreas and McHardy, Alice C. and Sczyrba, Alexander and Barton, Michael D.},
  title = "{Bioboxes: standardised containers for interchangeable bioinformatics software}",
  journal = {GigaScience},
  volume = {4},
  number = {1},
  pages = {s13742-015-0087-0},
  year = {2015},
  month = {10},
  abstract = "{Software is now both central and essential to modern biology, yet lack of availability, difficult installations, and complex user interfaces make software hard to obtain and use. Containerisation, as exemplified by the Docker platform, has the potential to solve the problems associated with sharing software. We propose bioboxes: containers with standardised interfaces to make bioinformatics software interchangeable.}",
  issn = {2047-217X},
  doi = {10.1186/s13742-015-0087-0},
  url = {https://doi.org/10.1186/s13742-015-0087-0},
  eprint = {https://academic.oup.com/gigascience/article-pdf/4/1/s13742-015-0087-0/25513237/13742\_2015\_article\_87.pdf},
}

@article{viereck19,
  doi = {10.21105/joss.01349},
  url = {https://doi.org/10.21105/joss.01349},
  year = {2019},
  publisher = {The Open Journal},
  volume = {4},
  number = {37},
  pages = {1349},
  author = {Martin Viereck},
  title = {x11docker: Run GUI applications in Docker containers},
  journal = {Journal of Open Source Software}
}

@article{boettiger15,
  author = {Boettiger, Carl},
  title = {An Introduction to Docker for Reproducible Research},
  year = {2015},
  issue_date = {January 2015},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {49},
  number = {1},
  issn = {0163-5980},
  url = {https://doi.org/10.1145/2723872.2723882},
  doi = {10.1145/2723872.2723882},
  abstract = {As computational work becomes more and more integral to many aspects of scientific research, computational reproducibility has become an issue of increasing importance to computer systems researchers and domain scientists alike. Though computational reproducibility seems more straight forward than replicating physical experiments, the complex and rapidly changing nature of computer environments makes being able to reproduce and extend such work a serious challenge. In this paper, I explore common reasons that code developed for one research project cannot be successfully executed or extended by subsequent researchers. I review current approaches to these issues, including virtual machines and workflow systems, and their limitations. I then examine how the popular emerging technology Docker combines several areas from systems research - such as operating system virtualization, cross-platform portability, modular re-usable elements, versioning, and a 'DevOps' philosophy, to address these challenges. I illustrate this with several examples of Docker use with a focus on the R statistical environment.},
  journal = {SIGOPS Oper. Syst. Rev.},
  month = {jan},
  pages = {71–79},
  numpages = {9}
}

@inproceedings{cito16,
  author = {Cito, J\"{u}rgen and Gall, Harald C.},
  title = {Using Docker Containers to Improve Reproducibility in Software Engineering Research},
  year = {2016},
  isbn = {9781450342056},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2889160.2891057},
  doi = {10.1145/2889160.2891057},
  abstract = {The ability to replicate and reproduce scientific results has become an increasingly important topic for many academic disciplines. In computer science and, more specifically, software engineering, contributions of scientific work rely on developed algorithms, tools and prototypes, quantitative evaluations, and other computational analyses. Published code and data come with many undocumented assumptions, dependencies, and configurations that are internal knowledge and make reproducibility hard to achieve. This technical briefing presents how Docker containers can overcome these issues and aid the reproducibility of research artifacts in software engineering and discusses their applications in the field.},
  booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion},
  pages = {906–907},
  numpages = {2},
  keywords = {reproducibility, cloud, containers},
  location = {Austin, Texas},
  series = {ICSE '16}
}

@article{emsley18,
  author = {Emsley, Iain and De Roure, David},
  year = {2018},
  month = {04},
  pages = {125-135},
  title = {A Framework for the Preservation of a Docker Container},
  volume = {12},
  journal = {International Journal of Digital Curation},
  doi = {10.2218/ijdc.v12i2.509},
  url = {http://www.ijdc.net/article/view/509},
}

@article{hosny16,
  author = {Hosny, Abdelrahman and Vera-Licona, Paola and Laubenbacher, Reinhard and Favre, Thibauld},
  title = "{AlgoRun: a Docker-based packaging system for platform-agnostic implemented algorithms}",
  journal = {Bioinformatics},
  volume = {32},
  number = {15},
  pages = {2396-2398},
  year = {2016},
  month = {03},
  abstract = "{Motivation: There is a growing need in bioinformatics for easy-to-use software implementations of algorithms that are usable across platforms. At the same time, reproducibility of computational results is critical and often a challenge due to source code changes over time and dependencies.Results: The approach introduced in this paper addresses both of these needs with AlgoRun, a dedicated packaging system for implemented algorithms, using Docker technology. Implemented algorithms, packaged with AlgoRun, can be executed through a user-friendly interface directly from a web browser or via a standardized RESTful web API to allow easy integration into more complex workflows. The packaged algorithm includes the entire software execution environment, thereby eliminating the common problem of software dependencies and the irreproducibility of computations over time. AlgoRun-packaged algorithms can be published on http://algorun.org, a centralized searchable directory to find existing AlgoRun-packaged algorithms.Availability and implementation: AlgoRun is available at http://algorun.org and the source code under GPL license is available at https://github.com/algorunContact:  laubenbacher@uchc.eduSupplementary information:  Supplementary data are available at Bioinformatics online.}",
  issn = {1367-4803},
  doi = {10.1093/bioinformatics/btw120},
  url = {https://doi.org/10.1093/bioinformatics/btw120},
  eprint = {https://academic.oup.com/bioinformatics/article-pdf/32/15/2396/49020253/bioinformatics\_32\_15\_2396.pdf},
}

@article{marwick17,
  author="Marwick, Ben",
  title="Computational Reproducibility in Archaeological Research: Basic Principles and a Case Study of Their Implementation",
  journal="Journal of Archaeological Method and Theory",
  year="2017",
  month="Jun",
  day="01",
  volume="24",
  number="2",
  pages="424--450",
  abstract="The use of computers and complex software is pervasive in archaeology, yet their role in the analytical pipeline is rarely exposed for other researchers to inspect or reuse. This limits the progress of archaeology because researchers cannot easily reproduce each other's work to verify or extend it. Four general principles of reproducible research that have emerged in other fields are presented. An archaeological case study is described that shows how each principle can be implemented using freely available software. The costs and benefits of implementing reproducible research are assessed. The primary benefit, of sharing data in particular, is increased impact via an increased number of citations. The primary cost is the additional time required to enhance reproducibility, although the exact amount is difficult to quantify.",
  issn="1573-7764",
  doi="10.1007/s10816-015-9272-9",
  url="https://doi.org/10.1007/s10816-015-9272-9"
}

@inproceedings{felter15,
  author={Felter, Wes and Ferreira, Alexandre and Rajamony, Ram and Rubio, Juan},
  booktitle={2015 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)},
  title={An updated performance comparison of virtual machines and Linux containers},
  year={2015},
  volume={},
  number={},
  pages={171-172},
  doi={10.1109/ISPASS.2015.7095802},
  url={https://ieeexplore.ieee.org/abstract/document/7095802}
}

@article{kurtzer17,
  doi = {10.1371/journal.pone.0177459},
  author = {Kurtzer, Gregory M. AND Sochat, Vanessa AND Bauer, Michael W.},
  journal = {PLOS ONE},
  publisher = {Public Library of Science},
  title = {Singularity: Scientific containers for mobility of compute},
  year = {2017},
  month = {05},
  volume = {12},
  url = {https://doi.org/10.1371/journal.pone.0177459},
  pages = {1-20},
  abstract = {Here we present Singularity, software developed to bring containers and reproducibility to scientific computing. Using Singularity containers, developers can work in reproducible environments of their choosing and design, and these complete environments can easily be copied and executed on other platforms. Singularity is an open source initiative that harnesses the expertise of system and software engineers and researchers alike, and integrates seamlessly into common workflows for both of these groups. As its primary use case, Singularity brings mobility of computing to both users and HPC centers, providing a secure means to capture and distribute software and compute environments. This ability to create and deploy reproducible environments across these centers, a previously unmet need, makes Singularity a game changing development for computational science.},
  number = {5},
}

@inproceedings{thalheim18,
  author = {Thalheim, J\"{o}rg and Bhatotia, Pramod and Fonseca, Pedro and Kasikci, Baris},
  title = {CNTR: Lightweight OS Containers},
  year = {2018},
  isbn = {9781931971447},
  publisher = {USENIX Association},
  address = {USA},
  abstract = {Container-based virtualization has become the de-facto standard for deploying applications in data centers. However, deployed containers frequently include a wide-range of tools (e.g., debuggers) that are not required for applications in the common use-case, but they are included for rare occasions such as in-production debugging. As a consequence, containers are significantly larger than necessary for the common case, thus increasing the build and deployment time.CNTR provides the performance benefits of lightweight containers and the functionality of large containers by splitting the traditional container image into two parts: the "fat" image--containing the tools, and the "slim" image -- containing the main application. At run-time, CNTR allows the user to efficiently deploy the "slim" image and then expand it with additional tools, when and if necessary, by dynamically attaching the "fat" image.To achieve this, CNTR transparently combines the two container images using a new nested namespace, without any modification to the application, the container manager, or the operating system. We have implemented CNTR in Rust, using FUSE, and incorporated a range of optimizations. CNTR supports the full Linux filesystem API, and it is compatible with all container implementations (i.e., Docker, rkt, LXC, systemd-nspawn). Through extensive evaluation, we show that CNTR incurs reasonable performance overhead while reducing, on average, by 66.6\% the image size of the Top-50 images available on Docker Hub.},
  booktitle = {Proceedings of the 2018 USENIX Conference on Usenix Annual Technical Conference},
  pages = {199–212},
  numpages = {14},
  location = {Boston, MA, USA},
  series = {USENIX ATC '18}
}

@article{flauzac20,
  title = {A review of native container security for running applications},
  journal = {Procedia Computer Science},
  volume = {175},
  pages = {157-164},
  year = {2020},
  note = {The 17th International Conference on Mobile Systems and Pervasive Computing (MobiSPC),The 15th International Conference on Future Networks and Communications (FNC),The 10th International Conference on Sustainable Energy Information Technology},
  issn = {1877-0509},
  doi = {https://doi.org/10.1016/j.procs.2020.07.025},
  url = {https://www.sciencedirect.com/science/article/pii/S187705092031704X},
  author = {Flauzac, Olivier and Mauhourat, Fabien and Nolot, Florent},
  keywords = {Containers, LXC, LXD, Singularity, Docker, Kata-containers, gVisor},
  abstract = {Containers offer an efficient solution allowing the application’s isolation. Most of the papers dealing with the container’s isolation focus on benchmarking container’s solutions. However, in this study, we focus on a static comparison of different features proposed by container solutions. First, we will focus on the container’s runtimes, then, we present the different solutions used in the study. The most common container solutions are compared, such as LXC, LXD, Singularity, Docker, Kata-containers, and gVisor. We consider container features as isolation, storage, network, and security capabilities. For each container feature, all container solutions will be compared to find the most efficient one. Finally, this paper compares the different default container configurations and attempts to find the most efficient container solution based on all compared features.}
}

@InProceedings{debab21,
  author="Debab, Ramzi and Hidouci, Walid Khaled",
  editor="Arai, Kohei and Kapoor, Supriya and Bhatia, Rahul",
  title="Containers Runtimes War: A Comparative Study",
  booktitle="Proceedings of the Future Technologies Conference (FTC) 2020, Volume 2 ",
  year="2021",
  publisher="Springer International Publishing",
  address="Cham",
  pages="135--161",
  abstract="Docker has revolutionized the cloud by popularizing containerization, changing the habits of developers and their tools, introducing new paradigms such as microservices and serverless computing, facilitating CI/CD pipelines and packaging techniques, inspiring Infrastructure as Code (IaC) and pushing the Software Defined Everything (SDx. Docker is omnipresent, on our laptops, servers, storage arrays and even on IoT devices. Docker had also the merit of defining standards such as the OCI initiative. Despite all this, can we trust this technology and deploy it widely in our private or public clouds? Given the few vulnerabilities of Docker but badly impactful, many Cloud players (Google, Amazon, RedHat, IBM, Intel, VMware among others) have worked on containerized house technologies made public. Four types of releases resulted: containerization based on OS virtualization, containerization based on micro VMs, syscalls virtualization and finally the Unikernels approach. In this article we will try to briefly present the recent containerization technologies respecting the OCI standards with a comparative study of performance. The purpose of this paper is to provide elements that help in decision-making for the choice of the most suitable container engine.",
  isbn="978-3-030-63089-8",
  url={https://link.springer.com/chapter/10.1007/978-3-030-63089-8_9}
}

@InProceedings{gantikow20,
  author="Gantikow, Holger and Walter, Steffen and Reich, Christoph",
  editor="Jagode, Heike and Anzt, Hartwig and Juckeland, Guido and Ltaief, Hatem",
  title="Rootless Containers with Podman for HPC",
  booktitle="High Performance Computing",
  year="2020",
  publisher="Springer International Publishing",
  address="Cham",
  pages="343--354",
  abstract="Containers have become popular in HPC environments to improve the mobility of applications and the delivery of user-supplied code. In this paper we evaluate Podman, an enterprise container engine that supports rootless containers, in combination with runc and crun as container runtimes using a real-world workload with LS-DYNA, and the industry-standard benchmarks sysbench and STREAM. The results suggest that Podman with crun only introduces a similar low overhead as HPC-focused container technologies.",
  isbn="978-3-030-59851-8",
  url={https://link.springer.com/chapter/10.1007/978-3-030-59851-8_23}
}

@InProceedings{espe20,
  author={Lennart Espe. and Anshul Jindal. and Vladimir Podolskiy. and Michael Gerndt.},
  title={Performance Evaluation of Container Runtimes},
  booktitle={Proceedings of the 10th International Conference on Cloud Computing and Services Science - CLOSER},
  year={2020},
  pages={273-281},
  publisher={SciTePress},
  organization={INSTICC},
  doi={10.5220/0009340402730281},
  isbn={978-989-758-424-4},
  issn={2184-5042},
}
